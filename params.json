{"name":"Oocsi-processing","tagline":"OOCSI library for Processing","body":"# oocsi-processing\r\n\r\nProcessing Library for the [OOCSI](https://github.com/iddi/oocsi) platform.\r\n\r\nThis platform can connect Windows, Mac and Linux computers (running Java and Processing), devices (Arduino, Raspberry Pi and Gadgeteer),\r\nWeb brosers (via websockets) and mobile devices (iOS and Android).\r\nPlease refer to the general documentation to know more about connection possibilities.  \r\n\r\n## Download\r\n\r\nFind the latest version of the library here: [oocsi-processing.zip](dist/oocsi.zip) (21kB)\r\n\r\nAlternatively, you can browse the source code on GitHub or clone the GitHub repository and get started with the code.\r\n\r\n## Installation\r\n\r\n1. Extract the zip file into the Processing libraries directory (in Windows processing-x.x.x\\modes\\java\\libraries\\)\r\n2. Restart Processing\r\n3. Open the examples browser in Processing, look for the Libraries >> oocsi folder \r\n\r\n\r\n## How to use\r\n\r\nEither use one of the examples from the Processing examples browser, or follow the short tutorial below.\r\n\r\nBefore starting with an OOCSI client running in Processing, you need to know how the OOCSI network looks like.\r\nYou will need an OOCSI server running either on your computer (_localhost_) or available from the network.\r\nAlso, any OOCSI client in the network is identified by a _unique name_, which serves also as an address if other clients in the OOCSI network want to messages. \r\n\r\n\r\n### Create an OOCSI client\r\n\r\nBefore you can send or receive messages, you will need to create an OOCSI client that connects to an OOCSI server (running at a specific address).\r\nWhen creating the client, you will need to supply also a _unique name_, which can be used as a handle if others want to send messages to your client. \r\n\r\nCreate a client that connects to an OOCSI server running on the local computer (running at _localhost_, see [here](https://https://github.com/iddi/oocsi/readme.md#running_local)):\r\n\r\n\tOOCSI oocsi = new OOCSI(this, \"unique name\", \"localhost\");    \r\n\r\nCreate a client that connects to an OOCSI server running at the address _oocsi.example.net_:\r\n\r\n\tOOCSI oocsi = new OOCSI(this, \"unique name\", \"oocsi.example.net\");\r\n\r\nAfter this statement, the OOCSI client _oocsi_ can be used in Processing code to send or subscribe for messages.\r\nPlease keep an eye on the Processing console where OOCSI will print start messages and also error, in case something goes wrong. \r\n\r\n\r\n### Subscribe to OOCSI channel\r\n\r\nOOCSI communications base on messages which are sent to channels or individual clients. For simplicity, clients are regarded as channels as well.\r\nOOCSI clients like the one created above can subscribe to channels, and from then on will receive all messages that are sent to the chosen channels.\r\nAlso, clients will receive all messages that are sent to their specific channel.\r\n\r\n\toocsi.subscribe(\"channel red\"); \r\n\r\nThis line will subscribe the client to the channel _channel red_. The client will receive all messages sent to that channel.\r\nTo actually receive something, the _handleOOCSIEvent_ function has to be in place: \r\n\r\n\tvoid handleOOCSIEvent(OOCSIEvent message) {\r\n\t\t// print out all values in message\r\n\t\tprintln(message.keys());\r\n\t}\r\n\t\r\nIn this example, all contents of a message are printed to the Processing console. These _keys_ can be used to retrieve values from the message, for example:\r\n\r\n\tvoid handleOOCSIEvent(OOCSIEvent message) {\r\n\t\t// print out the \"intensity\" value in the message\r\n\t\tprintln(message.get(\"intensity\"));\r\n\t}\r\n\t\r\nInstead of using \"handleOOCSIEvent\" as the default hub of all incoming OOCSI events, \r\nyou can create a new function with the same name as the channel you would like to subscribe to, \r\nand then this function will be called for incoming evens from that channel:\r\n\r\n\t...\r\n\t\r\n\toocsi.subscribe(\"testchannel\");\r\n\t\r\n\t...\r\n\r\n\tvoid testchannel(OOCSIEvent message) {\r\n\t\t// print out the \"intensity\" value in the message from channel \"testchannel\"\r\n\t\tprintln(message.get(\"intensity\"));\r\n\t}\r\n\t\r\nNote that for this only channel names without punctuation and whitespace characters are possible.\r\n\t\r\n\r\n### Send data to OOCSI channel\r\n\r\nSending data to the OOCSI network, for instance, to one specific channel or client is even easier: \r\n\r\n\toocsi.channel(\"channel red\").data(\"intensity\", 100).send();\r\n \r\nEssentially, sending messages follows three steps: \r\n\r\n1. Select a channel, for example: \"channel red\"\r\n2. Add data to the message, for example: \"intensity\" = 100\r\n3. Send the message to OOCSI\r\n \r\nThis composed message will then be send via the connected OOCSI server to the respective channel or client, in this case to \"channel red\". \r\n\r\n\r\n### Getting data from events\r\n\r\nAn OOCSIEvent has built-in infrastructure-level data fields such as _sender_, _timestamp_, and _channel_. In addition, the _recipient_ field is provided for some client implementations.\r\nEach of these fields can be access with a dedicated getter method:\r\n\r\n\tOOCSI event = ...\r\n\t\r\n\t// sender and receiver\r\n\tString sender = event.getSender();\r\n\tString channel = event.getChannel();\r\n\tString channel = event.getRecipient();\r\n\t\r\n\t// time\r\n\tDate timestamp = event.getTimestamp();\r\n\tlong unixTime = event.getTime();\r\n\t\r\nApart from that, OOCSIEvents have a data payload that is freely definable and realized as a key-value store (Map<String, Object>). Such key-value pairs can be accessed with helper mthods\r\nthat will convert the data type of hte value accordingly: \r\n\t \r\n\tOOCSI event = ...\r\n\tString stringValue = event.getString(\"mykey\");\r\n\tObject objectValue = event.getObject(\"mykey\");\r\n\t\r\nEvents do not guarantee that specific keys and values are contained. For these cases, default values can be used in the retrieval of event data. These default values (with the correct data type) are \r\nadded to the retrieval call as a second parameter, and they will be assigned if (1) the key could not be found, or (2) if the value could not converted to the specified data type.  \t\r\n\r\n\t// retrieval with an additional default value\r\n\tOOCSI event = ...\r\n\tString stringValue = event.getString(\"mykey\", \"default\");\r\n\tlong longValue = event.getLong(\"mykey\", 0);\r\n\tint intValue = event.getInt(\"mykey\", 0);\r\n\tboolean booleanValue = event.getInt(\"mykey\", false);\r\n\r\nAs an alternative to using default values, one can also check whether the key is contained in the event:\r\n\r\n\tOOCSI event = ...\r\n\tif(event.has(\"mykey\")) {\r\n\t\t// retrieve value\r\n\t}\r\n\t\r\nFinally, events can provide a list of contained keys, which can be used to dump all contained data or to systematically retrieve all data.\r\n\r\n\tOOCSI event = ...\r\n\tString[] keys = event.keys();\r\n\r\n\r\n\r\n### Full example\r\n\r\nAs a full example, we build a simple counter that will count from 0 up till the sketch is stopped.\r\nIn the _setup_ function, a connection to the OOCSI network is established with the handle \"counterA\", and after that,\r\nan initial message with counter = 0 is sent to \"counterA\" via the OOCSI network. In the _handleOOCSIEvent_ function,\r\nevery time a message with a counter value is received, the sketch will send it out to handle \"counterA\" again with the counter increased by 1.\r\nWhen pasting the following code into Processing and running it, the Processing console should show a fast sequence of increasing numbers.\r\n\r\n\timport nl.tue.id.oocsi.*;\r\n\t\r\n\tOOCSI oocsi;\r\n\t\r\n\tvoid setup () {\t\r\n\t  oocsi = new OOCSI(this, \"counterA\", \"localhost\");\r\n\t  oocsi.channel(\"counterA\").data(\"count\", 0).send();\r\n\t}\r\n\t\r\n\tvoid handleOOCSIEvent(OOCSIEvent e) {\r\n\t  int count = e.getInt(\"count\", 0);\r\n\t  println(count);\r\n\t  oocsi.channel(\"counterA\").data(\"count\", count + 1).send();\r\n\t}\r\n\r\n\r\n### Other examples \r\n\r\nThe OOCSI Processing plugin comes with 3 examples that demonstrate parts of the functionality.\r\nAll examples require an OOCSI server running on the same computer (running at _localhost_, see [here](https://https://github.com/iddi/oocsi/readme.md#running_local)).\r\nThe examples are available from the Processing examples browser, or below:\r\n\r\n1. Client to client message sending _via a direct link_:\r\n\t- [DirectReceiver](dist/oocsi/examples/DirectReceiver/DirectReceiver.pde) (start this first)\r\n\t- [DirectSender](dist/oocsi/examples/DirectSender/DirectSender.pde) (move mouse over the window, receiver window should show a moving square)\r\n\r\n\r\n2. Client to client message sending and receiving _via a channel_:\r\n\t- [ChannelReceiver](dist/oocsi/examples/ChannelReceiver/ChannelReceiver.pde) (start this first)\r\n\t- [ChannelSender](dist/oocsi/examples/ChannelSender/ChannelSender.pde) (move mouse over the window, receiver window should show a moving square)\r\n\r\n\r\n3. Getting an updated list of all connected clients\r\n\t- [Tools_ClientLister](dist/oocsi/examples/Tools_ClientLister/Tools_ClientLister.pde)\r\n\t\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}